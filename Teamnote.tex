\documentclass[landscape]{article}
\linespread{1}
\usepackage{multicol}
\setlength{\columnsep}{0.5cm}
\setlength{\columnseprule}{0.25pt}
\usepackage{amsmath}
\usepackage{graphbox}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{subcaption}
\usepackage{geometry}
\geometry{a4paper, landscape, margin = 0.6in}
\usepackage{enumerate}
\usepackage{amsthm}
\usepackage{physics}
\usepackage{float}
\usepackage{kotex}
\usepackage{tabu}
\usepackage{listings}
\usepackage{wrapfig}
\usepackage{authblk}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead[R]{ICPC 2020 Teamnote}
\fancyhead[L]{Seoul National University : Swift Turtwig}
\usepackage[compact]{titlesec}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\newcommand{\st}{\text{ such that }}
\newcommand{\for}{\text{ for }}
\newcommand{\newpara}[1]{\paragraph{#1} \mbox{}\\}
\everymath{\displaystyle}
\setlength{\parskip}{0pt}
\setlength{\parsep}{-2pt}
\setlength{\parindent}{0pt}
\titlespacing{\section}{0pt}{*0}{*0}
\titlespacing{\subsection}{0pt}{*1}{*0.5}
\titlespacing{\subsubsection}{0pt}{*0}{*0}
\topsep=5pt \partopsep=5pt
\setlength{\headheight}{12pt}
\setlength{\headsep}{8pt}
\setlength{\topmargin}{-65pt}
\title{\Huge{\textsf{ICPC TEAMNOTE}}}
\author{}
\date{ }

\usepackage{etoolbox}

\makeatletter
\patchcmd{\verbatim@input}{\@verbatim}{\@verbatim}{}{}
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% DO NOT MODIFY ABOVE PREAMBLE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\begin{document}
\newpage
\begin{multicols}{2}\raggedcolumns
    \tableofcontents
    \pagebreak
\end{multicols}
\begin{multicols}{3 }\raggedcolumns


\section{Data Structures}
    \subsection{Disjoint Set Union}
        \verbatiminput{./code/DataStructures/DisjointSetUnion.cpp}
    \subsection{Segment Tree (with Lazy propagation)}
        Incremental modifications with lazy propagation. All intervals are $[l, r)$.
        \verbatiminput{./code/DataStructures/SegmentTree.cpp}
    \subsection{2D Segment Tree}
        Point update, rectangle query. All intervals are $[a, b] \times [c, d]$.
        \verbatiminput{./code/DataStructures/2DSegmentTree.cpp}
    \subsection{Merge Sort Tree}
        greater(s, e, k, 1, 0, n) : How many elements in range [s, e) are strictly greater than $k$?
        \verbatiminput{./code/DataStructures/MergeSortTree.cpp}


\section{Dynamic Programming}
    \subsection{Li Chao Tree}
        Objective\\
        (1) Line insert query (ax + b)\\
        (2) Max / Min on x = t query\\
        Current Implementation : Max query\\
        \verbatiminput{./code/DynamicProgramming/LiChaoTree.cpp}

\section{Mathematics}
    \subsection{Fast Fourier Transform}
        Multiply two polynomials in $O(n \log n)$. For
        \verbatiminput{./code/Math/FFT.cpp}

    \subsection{Berlekamp Massey Algorithm}
        Find minimum linear recurrence from $3n$ first terms.
        \verbatiminput{./code/Math/Berlekamp-Massey.cpp}

\section{Geometry}
    \subsection{Point header}
        Use as \texttt{typedef Point<double> P;}
        \verbatiminput{./code/Geometry/Point.h}
    \subsection{Line / Line segment}
        \texttt{lineDist} : Returns the signed distance between point p and the line containing points a and b. Positive value on left side and negative on right as seen from a towards b. a==b gives nan.\\
        \texttt{lineInter, segInter} : Unique intersection : (1, point), No intersection : (0, (0, 0)), Infinitely many : (-1, (0, 0)).\\
        \texttt{segDist} : Return shortest distance between p and segment $[s, e]$.
        \verbatiminput{./code/Geometry/LineSegments.cpp}

    \subsection{Polygons}
        \verbatiminput{./code/Geometry/ConvexHull.cpp}
            \begin{itemize}
                \item $(-1, -1)$ if no collision,
                \item $(i, -1)$ if touching the corner $i$,
                \item $(i, i)$ if along side $(i, i+1)$,
                \item $(i, j)$ if crossing sides $(i, i+1)$ and $(j, j+1)$.
            \end{itemize}
        \verbatiminput{./code/Geometry/Polygon.cpp}

\section{Graph}
    \subsection{Network Flow}
        \subsubsection{Dinic's Maxflow}
            Fast max flow algorithm. Use \texttt{maxflow} and \texttt{AddEdge}.
            \verbatiminput{./code/Graph/Dinic.cpp}
        \subsubsection{Min cost Max Flow}
            Fast min cost max flow algorithm. Use \texttt{solveMCMF} and \texttt{AddEdge}.\\
            solveMCMF returns pair of (max flow, cost of such flow).
            \verbatiminput{./code/Graph/MCMF.cpp}

\section{String}
    \subsection{KMP}
        Pi 배열의 정의 : $str[0]$ 부터 $str[i]$ 까지 중 접두사가 접미사와 같은 부분만큼의 길이.
        \verbatiminput{./code/String/KMP.cpp}
    \subsection{Manacher}
        A[i] = $i$ 번을 중심으로 하는 가장 긴 팰린드롬이 되는 반지름.
        \verbatiminput{./code/String/Manacher.cpp}


\section{Misc}
    \subsection{GCC Extensions : OST}
        \verbatiminput{./code/Misc/pbds_ost.cpp}
\eject{}
\end{multicols}
\end{document}
